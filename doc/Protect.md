# 特权级概述

## 特权级引入

从 80286 处理器开始，Intel 引入了**保护模式**，而**特权级**是保护模式中的一个重要概念。

我们将 80286 之前的处理器运行的模式称为 **实模式**，即寻址方式是通过给出代码段的基地址 CS 和偏移地址 IP，就可直接访问该内存。实模式下无法对代码的执行权限和访问权限进行控制。

在保护模式中，CPU 采用了 **段保护机制**，一个程序需要用到哪些段，需要告诉操作系统，由操作系统登记到描述符表中，并注明段界限、类型等属性，这样当程序想往代码段写数据时，或者让处理器访问超过段界限的内存区域时，处理器就会引发异常中断。

但是只有段保护机制的话，并不能确保操作系统的安全性。

如果一个恶意程序知道 GDT 表的位置，它就可以将系统的段描述符加载到段寄存器中，然后“合法”地访问系统私有数据；又或者，它可以在 GDT 表中私自增加一个描述符，让它指向系统数据区，然后就可以通过加载该描述符到段寄存器来访问系统私有数据！

显然，还需要进一步完善保护机制，于是特权级就派上用场了。特权级的数值范围为 0~3，即数值越小特权级越高。特权级有 DPL、RPL、CPL 三种。要让处理器访问其它数据段或转移到其它代码段时，需要通过 **特权级检查**，如果不能通过，就会产生 **通用保护错误**，以此确保代码安全执行。

通常来说，操作系统的核心代码运行在最高特权级（0 特权级）上，而用户程序运行在最低特权级（3 特权级上），特权级 1 和 2 一般用于运行系统服务程序。

## 特权级分类

    DPL：Descriptor Privilege Level，描述符特权级

    RPL：Request Privilege Level，请求特权级

    CPL：Current Privilege Level，当前特权级

* 描述符特权级(DPL) 位于描述符的属性字段, 如下图: 

![DPL](http://static.codebelief.com/2018/01/07/descriptor.png)

DPL决定了访问数据/代码段所需要的的最低特权级别, 有依从/不依从之分

* 请求特权级(RPL) 位于选择符中的 RPL 字段：

![RPL](http://static.codebelief.com/2018/01/07/selector.png)

* 当前特权级(CPL) 位于代码段寄存器（CS）的低两位。我们可以认为 CPL 就是特殊的 RPL，因为它是存放在当前 CS 中的选择符的 RPL 值。

![CPL](http://static.codebelief.com/2018/01/07/selector.png)

## 特权级作用

上面提到的三种特权级都是为了让系统更安全地运行，阻止某些危险的指令操作。

我们看看定义了这么多特权级，它们分别是用来干嘛的。

CPL 比较容易理解，我们需要用它来判断当前正在执行的代码处于哪个特权级，这样才能对它的行为做出限制。

DPL 表示描述符的特权级，我们根据它来判断程序是否有足够权限对相关的段进行某些操作。

RPL 就是请求者的特权级别。我们要访问某个数据段、跳转到某个代码段、调用某个例程，都可以视为请求，而发出这个请求的就称为请求者。

可能你问：发出请求的不就是当前程序吗？既然当前程序是请求者，直接用 CPL 就可以表示了，为什么要多一个 RPL？

通常情况下，请求者就是当前程序本身，此时 RPL = CPL。但并非所有情况都是如此，例如由于 I/O 特权级的限制，用户程序（特权级为 3）不能自己访问硬盘，但可以通过调用门借助系统例程来完成访问。当执行系统例程进行 I/O 操作时，当前程序就是系统例程，而请求者就是用户程序，CPL = 0，而 RPL = 3。

引入 RPL 是为了帮助处理器在遇到一条将选择子传送到段寄存器的指令时，能够区分真正的请求者是谁。

## 不同特权级之间的转移

代码段的特权级检查非常严格。一般来说，控制转移只允许发生在两个特权级相同的代码段之间。

但是，为了让特权级低的应用程序可以调用特权级高的操作系统例程，处理器允许通过某些方式在不同特权级的代码段之间转移控制，下面将会介绍。

**但是无论是通过什么方式转移，都只允许低特权级代码调用（或 JMP）高特权级代码，处理器不允许高特权级代码调用低特权级代码。**

我们以内核和用户程序为例，内核的特权级最高（0 特权级），而用户程序的权限最低（3 特权级）。处理器允许用户程序调用内核代码，但不允许内核调用用户程序的代码。为什么？

这跟直观上的感受有点矛盾。特权级越高，不应该越不受限制吗，怎么高特权级反而不能调用低特权级的代码呢？

可以这么理解：内核不会调用可靠性低的用户程序代码。如果内核可以通过 CALL 指令调用用户程序代码，那么万一该程序是恶意的，而返回地址又是由该程序给出的，那么用户程序就很有可能让处理器转移到别的恶意代码中。

### 使用一致代码段

通过将高特权级代码段定义为一致的（conforming），就能让低特权级程序调用该高特权级代码段。

一致代码段的特点是，当转移到该代码段时，CPL 与之前保持一致。

当一个高特权级代码段被定义为一致性代码段时，那么特权级与它相同，或比它低的程序都可以调用它。

顺便提一下，如果要调用的是非一致代码段，那么特权级必须与之相等。

### 使用门描述符

另一种在特权级间转移控制的方法是使用门。

段描述符用于描述内存段，门描述符则用于描述可执行的代码，例如一个程序、一个过程或者一个任务。

不同特权级间的过程调用可以使用调用门，中断处理过程使用中断门或陷阱门，任务间的切换使用任务门。

调用门是安装在描述符表（GDT 或 LDT）中的描述符，它的格式如下：

![](http://static.codebelief.com/2018/01/10/call_gate.png)

调用门中包含了段选择符，指向目标代码段。调用门就像一个中间者一样，我们可以通过它来转移到更高特权级的目标代码段。

如果使用 jmp far 指令，通过调用门转移控制时，无论目标代码段的特权级是否比当前特权级高，当前特权级都不会发生改变。

如果使用 call far 指令，通过调用门转移控制时，当前特权级会提升到目标代码段的特权级。

### 强制转移到低特权级

我们之前说过，处理器不允许高特权级调用低特权级代码。

但是如果我们确实需要从高特权级代码转移到低特权级代码段怎么办？就像在《Linux 内核完全注释》的 Linux 0.00 实验中那样，当内核完成初始化的工作之后，要开始执行用户程序，此时就需要从特权级 0 转移到特权级 3.书中采用的方式是 **模拟中断返回**。

![](http://static.codebelief.com/2018/01/11/interrupt_simulation.png)

也就是说，我们把当前的环境伪造成中断现场，往堆栈里压入用户程序的 SS、ESP、EFLAGS、CS、EIP，当执行 iret 指令时，处理器会认为是中断程序执行完毕，于是将堆栈里的各个寄存器值弹出到对应寄存器中，并开始执行用户程序，此时 CPL 也变为用户程序的特权级 3。

此外，还可以像《x86汇编语言：从实模式到保护模式》第十四章的内核程序那样，在内核初始化结束后，要切换到特权级为 3 的用户程序时，**模拟调用门返回**：

![](http://static.codebelief.com/2018/01/11/call_gate_simulation.png)

总之，处理器不允许控制权直接从高特权级代码转移到低特权级代码，如果要实现，就必须模拟某个低特权级调用高特权级代码的中间过程，通过返回的形式，从高特权级转移到低特权级。

## 特权级检查规则

### 数据段

数据段的特权级检查规则与我们的直观感受相符。当前特权级越高，访问数据段就越不会受到限制。

也就是说，当前特权级高于或等于要访问的数据段 DPL 时，才能通过特权级检查。

数值上可表示为：RPL、CPL <= DPL

注意：如果是通过段寄存器 SS 访问数据段，则要求 CPL、RPL = DPL

### 代码段

如上面所介绍，CPU 只允许低特权级调用高特权级的代码，所以只有在当前特权级低于或等于目标代码段的 DPL 时，才允许进行控制转移。

数值上可表示为：RPL、CPL >= DPL

CPL 只有在一种情况下会改变：CALL 指令通过调用门转移到特权级更高的代码段。

### 调用门

使用调用门时涉及到两个 DPL：一个是调用门描述符自身的 DPL，另一个是目标代码段（调用门中段选择符对应的代码段）的 DPL。

调用门自身的 DPL 检查规则与数据段的规则一样，就是当前特权级必须足够高，才能够对调用门进行调用。但由于只能低特权级代码调用高特权级代码，所以又要求当前特权级要低于或等于目标代码段的特权级。

因此，检查特权级时，数值上应该满足：

RPL、CPL <= 调用门 DPL

RPL、CPL >= 目标代码段 DPL
任务门

当要使用 JMP 或 CALL 通过任务门来切换任务时，特权级的检查规则与访问数据段的规则一致。

即数值上：RPL、CPL <= DPL


## 描述符定义

![DPL](http://static.codebelief.com/2018/01/07/descriptor.png)

 (1) P:    存在(Present)位。
		P=1 表示描述符对地址转换是有效的，或者说该描述符所描述的段存在，即在内存中；
		P=0 表示描述符对地址转换无效，即该段不存在。使用该描述符进行内存访问时会引起异常。

 (2) DPL:  表示描述符特权级(Descriptor Privilege level)，共2位。它规定了所描述段的特权级，用于特权检查，以决定对该段能否访问。 

 (3) S:   说明描述符的类型。
		对于存储段描述符而言，S=1，以区别与系统段描述符和门描述符(S=0)。 

 (4) TYPE: 说明存储段描述符所描述的存储段的具体属性。对S=0和S=1有不同类型
	
 (5) G:    段界限粒度(Granularity)位。
		G=0 表示界限粒度为字节；
		G=1 表示界限粒度为4K 字节。
           注意，界限粒度只对段界限有效，对段基地址无效，段基地址总是以字节为单位。 

 (6) D:    D位是一个很特殊的位，在描述可执行段、向下扩展数据段或由SS寄存器寻址的段(通常是堆栈段)的三种描述符中的意义各不相同。 
           ⑴ 在描述可执行段的描述符中，D位决定了指令使用的地址及操作数所默认的大小。
		① D=1表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段；
		② D=0 表示默认情况下，使用16位地址及16位或8位操作数，这样的代码段也称为16位代码段，它与80286兼容。可以使用地址大小前缀和操作数大小前缀分别改变默认的地址或操作数的大小。 
           ⑵ 在向下扩展数据段的描述符中，D位决定段的上部边界。
		① D=1表示段的上部界限为4G；
		② D=0表示段的上部界限为64K，这是为了与80286兼容。 
           ⑶ 在描述由SS寄存器寻址的段描述符中，D位决定隐式的堆栈访问指令(如PUSH和POP指令)使用何种堆栈指针寄存器。
		① D=1表示使用32位堆栈指针寄存器ESP；
		② D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。 

 (7) AVL:  软件可利用位。80386对该位的使用未左规定，Intel公司也保证今后开发生产的处理器只要与80386兼容，就不会对该位的使用做任何定义或规定。 

## 选择子定义

![CPL](http://static.codebelief.com/2018/01/07/selector.png)

 RPL(Requested Privilege Level): 请求特权级，用于特权检查。

 TI(Table Indicator): 引用描述符表指示位
	TI=0 指示从全局描述符表GDT中读取描述符；
	TI=1 指示从局部描述符表LDT中读取描述符。

